[
  {
    "title": "Shared versus Owned Objects Overview",
    "description": "This section explains the difference between shared and owned objects in Sui. Shared objects can be accessed by any transaction, while owned objects are restricted to their owner. It discusses trade-offs between latency, gas costs, and coordination needs for applications using these object types.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "markdown",
    "code": "Objects on Sui can be shared (accessible for reads and writes by any transaction) or owned (accessible for reads and writes by transactions signed by their owner). Many applications can be built using a solution that either uses shared objects or only owned objects, with trade-offs for each that need to be weighed.\n\nTransactions that use only owned objects benefit from very low latency to finality, because they do not need to go through consensus. On the other hand, the fact that only the owner of the object can access it complicates processes that need to work with objects owned by multiple parties, and access to very hot objects needs to be coordinated off-chain.\n\nTransactions that access one or more shared objects require consensus to sequence reads and writes to those objects, resulting in a slightly higher gas cost and increased latency.\n\nTransactions that access multiple shared objects, or particularly popular objects, might have increases in latency due to contention. However, the advantage of using shared objects lies in the flexibility of allowing multiple addresses to access the same object in a coordinated manner.",
    "mentions": [
      "Sui",
      "owned objects",
      "shared objects"
    ]
  },
  {
    "title": "Escrow Example Trade-offs",
    "description": "The Escrow example demonstrates the trade-offs between shared and owned objects by implementing the same application in both styles. Both styles enable a trustless swap of objects between two addresses, with the service holding those objects in escrow.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "markdown",
    "code": "The Escrow example demonstrates the trade-offs between shared and owned objects by implementing the same application in both styles. Both styles of the example implement a service that enables a trustless swap of objects between two addresses (a \"trade\"), with the service holding those objects in escrow.",
    "mentions": [
      "Escrow",
      "trustless swap"
    ]
  },
  {
    "title": "Locked<T> and Key Interface",
    "description": "This code sample shows the interface for a primitive that locks values, providing functions to lock and unlock values. The locked value can only be modified after unlocking, ensuring tamper resistance by requiring a key.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "move",
    "code": "module escrow::lock {\n    public fun lock<T: store>(obj: T, ctx: &mut TxContext): (Locked<T>, Key);\n    public fun unlock<T: store>(locked: Locked<T>, key: Key): T\n}",
    "mentions": [
      "Locked",
      "Key",
      "store"
    ]
  },
  {
    "title": "Owned Object Protocol",
    "description": "This section describes the protocol for swapping via escrow using owned objects. Both parties lock their objects, exchange keys, and a custodian acts as an intermediary to complete the swap.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "markdown",
    "code": "The protocol for swapping via escrow implemented using owned objects starts with both parties locking their respective objects.\n\nBuyer\nescrow::lock\nLocked< B>,  key_b\n B\nSeller\nescrow::lock\nLocked< S>,  key_s\n S\nThis is used to prove that the object has not been tampered with after the swap has been agreed to. If either party doesn't want to proceed at this stage, they just unlock their object.",
    "mentions": [
      "escrow",
      "custodian"
    ]
  },
  {
    "title": "Create Function for Owned Object Escrow",
    "description": "The create function prepares an escrow request and sends it to the custodian. It unlocks the offered object while remembering the ID of its key, ensuring that the custodian can only match objects with their correct counterpart.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "move",
    "code": "public fun create<T: key + store>(\n    key: Key,\n    locked: Locked<T>,\n    exchange_key: ID,\n    recipient: address,\n    custodian: address,\n    ctx: &mut TxContext,\n) {\n    let escrow = Escrow {\n        id: object::new(ctx),\n        sender: ctx.sender(),\n        recipient,\n        exchange_key,\n        escrowed_key: object::id(&key),\n        escrowed: locked.unlock(key),\n    };\n\n    transfer::transfer(escrow, custodian);\n}",
    "mentions": [
      "Escrow",
      "Key",
      "Locked",
      "object",
      "transfer"
    ]
  },
  {
    "title": "Swap Function for Owned Object Escrow",
    "description": "The swap function checks that senders and recipients match and ensures each party wants the object offered by the other by comparing key IDs. It prevents invalid swaps by verifying the correctness of the escrowed objects.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "move",
    "code": "public fun swap<T: key + store, U: key + store>(obj1: Escrow<T>, obj2: Escrow<U>) {\n    let Escrow {\n        id: id1,\n        sender: sender1,\n        recipient: recipient1,\n        exchange_key: exchange_key1,\n        escrowed_key: escrowed_key1,\n        escrowed: escrowed1,\n    } = obj1;\n\n    let Escrow {\n        id: id2,\n        sender: sender2,\n        recipient: recipient2,\n        exchange_key: exchange_key2,\n        escrowed_key: escrowed_key2,\n        escrowed: escrowed2,\n    } = obj2;\n    id1.delete();\n    id2.delete();\n\n    // Make sure the sender and recipient match each other\n    assert!(sender1 == recipient2, EMismatchedSenderRecipient);\n    assert!(sender2 == recipient1, EMismatchedSenderRecipient);\n\n    // Make sure the objects match each other and haven't been modified\n    // (they remain locked).\n    assert!(escrowed_key1 == exchange_key2, EMismatchedExchangeObject);\n    assert!(escrowed_key2 == exchange_key1, EMismatchedExchangeObject);\n\n    // Do the actual swap\n    transfer::public_transfer(escrowed1, recipient1);\n    transfer::public_transfer(escrowed2, recipient2);\n}",
    "mentions": [
      "Escrow",
      "transfer",
      "assert",
      "EMismatchedSenderRecipient",
      "EMismatchedExchangeObject"
    ]
  },
  {
    "title": "Shared Object Protocol",
    "description": "The protocol for the shared object case starts with the first party locking the object they want to swap. The second party can then view the locked object and create a swap request if they are interested.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "markdown",
    "code": "The protocol in the shared object case is less symmetric, but still starts with the first party locking the object they want to swap.\n\nBuyer\nescrow::lock\nLocked< B>,  key_b\n B\nThe second party can then view the object that was locked, and if they decide they want to swap with it, they indicate their interest by creating a swap request:\n\nSeller\ncreate\nEscrow< S>\n S,\nexchange_key:  key_b,\nrecipient: Buyer",
    "mentions": [
      "escrow",
      "Locked"
    ]
  },
  {
    "title": "Create Function for Shared Object Escrow",
    "description": "The create function accepts the object being escrowed directly, creates a shared Escrow object, and records the sender and recipient. It emits an event and adds the escrowed object to the shared object.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "move",
    "code": "public fun create<T: key + store>(\n    escrowed: T,\n    exchange_key: ID,\n    recipient: address,\n    ctx: &mut TxContext,\n) {\n    let mut escrow = Escrow<T> {\n        id: object::new(ctx),\n        sender: ctx.sender(),\n        recipient,\n        exchange_key,\n    };\n    event::emit(EscrowCreated {\n        escrow_id: object::id(&escrow),\n        key_id: exchange_key,\n        sender: escrow.sender,\n        recipient,\n        item_id: object::id(&escrowed),\n    });\n\n    dof::add(&mut escrow.id, EscrowedObjectKey {}, escrowed);\n\n    transfer::public_share_object(escrow);\n}",
    "mentions": [
      "Escrow",
      "event",
      "dof",
      "transfer",
      "object"
    ]
  },
  {
    "title": "Swap Function for Shared Object Escrow",
    "description": "The swap function allows the recipient to exchange an object with the escrowed item. It checks that the locked object matches the one requested, ensures the recipient is authorized, and completes the swap by transferring the objects.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "move",
    "code": "public fun swap<T: key + store, U: key + store>(\n    mut escrow: Escrow<T>,\n    key: Key,\n    locked: Locked<U>,\n    ctx: &TxContext,\n): T {\n    let escrowed = dof::remove<EscrowedObjectKey, T>(&mut escrow.id, EscrowedObjectKey {});\n\n    let Escrow {\n        id,\n        sender,\n        recipient,\n        exchange_key,\n    } = escrow;\n\n    assert!(recipient == ctx.sender(), EMismatchedSenderRecipient);\n    assert!(exchange_key == object::id(&key), EMismatchedExchangeObject);\n\n    // Do the actual swap\n    transfer::public_transfer(locked.unlock(key), sender);\n\n    event::emit(EscrowSwapped {\n        escrow_id: id.to_inner(),\n    });\n\n    id.delete();\n\n    escrowed\n}",
    "mentions": [
      "Escrow",
      "dof",
      "transfer",
      "assert",
      "event",
      "EMismatchedSenderRecipient",
      "EMismatchedExchangeObject"
    ]
  },
  {
    "title": "Comparison of Owned and Shared Object Approaches",
    "description": "This section compares the two approaches for implementing a swap. The owned object approach requires a custodian and involves more steps, while the shared object approach uses consensus but reduces steps and eliminates the need for a third party.",
    "source": "https://github.com/optimizely-axiom/optiaxiom/blob/main/packages/web-components/README.md#_snippet_0",
    "language": "markdown",
    "code": "In one case, the protocol uses only owned objects but requires a custodian to act as an intermediary. This has the advantage of avoiding the costs and latencies of consensus altogether, but involves more steps and requires trusting a third party for liveness.\n\nIn the other case, the object is custodied on chain in a shared object. This requires consensus but involves fewer steps, and no third party.",
    "mentions": [
      "custodian",
      "consensus"
    ]
  }
]